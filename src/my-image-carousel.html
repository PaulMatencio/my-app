<!--   Based on Codelabs for building a Ploymer 2.0 carsousel -->
<link rel="import" href="../bower_components/polymer/polymer-element.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-if.html">
<link rel="import" href="../bower_components/polymer/lib/elements/dom-repeat.html">
<link rel="import" href="../bower_components/iron-icons/iron-icons.html">
<link rel="import" href="../bower_components/iron-icons/av-icons.html">
<link rel="import" href="../bower_components/paper-slider/paper-slider.html">
<link rel="import" href="../bower_components/paper-icon-button/paper-icon-button.html">

<link rel="import" href="icon-toggle.html">
<!--link rel="import" href="/bower_components/polymer/lib/utils/flattened-nodes-observer.html"-->
<!--link rel="import" href="bower_components/polymer/lib/elements/dom-repeat.html"-->
<link rel="import" href="my-image-carousel-mixin.html">
<link rel="import" href="my-paper-icon-button-custom-styles.html">

<dom-module id="my-image-carousel">
  <template>
    <!-- Styles MUST be inside template -->
    <custome-style>
      <style include="my-paper-icon-button-custom-styles"></style>
    </custom-style>

    <style include="shared-styles"></style>
    <style>

      :host {
        display: block;
        position: relative;
        overflow: hidden;
      }

      /**
       * In a shadow root, the :host CSS selector refers to the host of the
       * shadow root (i.e. the <my-carousel> element), and the :slotted() selector
       * refers to the immediate children that are in that slot.
       * Though this is not required with the native implementation, one of
       * the limitations of the Shady DOM polyfill is that you must have a selector
       * to the left of ::slotted(). In this case, we will use div > ::slotted().
      */

      /* slot replace content
      */
      div > ::slotted(:not([selected])) {
        display: none;
      }

      button {
        position: absolute;
        top: calc(50% - 20px);
        padding: 0;
        line-height: 40px;
        border: none;
        background: none;
        color: #DDD;
        font-size: 40px;
        font-weight: bold;
        opacity: 0.9;
      }

      button:hover,
      button:focus {
        opacity: 1;
      }

      #prevBtn {
        left: calc(var(--iron-icon-width, 24px)/2);
      }

      #nextBtn {
        right: calc(var(--iron-icon-width, 24px)/2);
      }

      /* NAVIGATION ICONS */
      .navigation-icons {
        @apply --layout;
        @apply --layout-center;
        display: inline-flex;
        position: absolute;
        height: calc(var(--iron-icon-height, 24px) + 5px);
        background: var(--image-carousel-navigation-icon-color, rgba(255, 255, 255, 1));
        box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14),
                    0 1px 5px 0 rgba(0, 0, 0, 0.12),
                    0 3px 1px -2px rgba(0, 0, 0, 0.2);
        transition: box-shadow 0.28s cubic-bezier(0.4, 0, 0.2, 1);
        border-radius: 25%;
        background-color:  white;
        cursor: pointer;
      }

      .first-icon {
        left: calc(50% - var(--iron-icon-width)*2 - (var(--iron-icon-width) / 4 ));
        bottom: 5px;
        @apply --left-navigation-icon-mixin;
      }

      .bar-icon {
        padding: calc(var(--iron-icon-width) / 4);
      }

      .toggle-icon{
        right: calc(var(--iron-icon-width,24px));
        bottom:  5px;
      }

      .toggle-icon:hover .stop::after{
        position: relative;
        content: 'Stop scrolling';
        color: white;
        background-color: black;
        padding: 3px 8px;
      }

      .toggle-icon:hover .start::after {
        position: relative;
        content: 'Start scrolling';
        color: white;
        background-color: black;
        padding: 3px 8px;
      }

      .info {
        position: absolute;
        display: inline-flex;
        left:  calc(var(--iron-icon-width,24px));
        top: 0;
        font-size: 14px;
        padding: 0;
        margin: 0;
      }

      .download {
        position: absolute;
        display: inline-block;
        left:  70%;
        top: calc(var(--iron-icon-width, 24px)/2);
        font-size: 14px;
        padding: 0;
        margin: 0;
      }

      button[disabled] {
        opacity: 0.3;
        color: red;
      }

      span {
        padding: 2px;
      }



      @media (max-width: 1288px) {
        my-image-carousel::after {
          padding-top: 70%;
        }
      }

    </style>

    <!--  include custom style   -->


    <div>
      <slot></slot>
    </div>

    <button id="prevBtn" on-click="previous_image">&#x276E;</button>
    <button id="nextBtn" on-click="next_image">&#x276F;</button>

    <dom-if if="[[actions]]">
      <template>
        <div class="info">
          <!--p> {{ _title }} </p-->
          <dom-if if="[[autoscroll]]">
            <template>
              <paper-slider value="{{int}}" max="[[max]]" step="[[_step]]" max-marker="40" on-tap="set_interval" ></paper-slider>
              <p >{{int}} ms</p>
            </template>
          </dom-if>
        </div>

        <div  id="download" class="download">
          <template is="dom-repeat" items="[[Images]]">
            <a href = "[[item]]" download hidden$="[[autoscroll]]">
              <img border="1" src="[[item]]" alt="png" width="60" height="60">
            </a>
          </template>
        </div>

        <div class="navigation-icons toggle-icon">
          <dom-if if="[[autoscroll]]">
            <template>
              <span class="stop"> </span>
            </template>
          </dom-if>
          <dom-if if="[[!autoscroll]]">
            <template>
              <span class="start">  </span>
            </template>
          </dom-if>
          <icon-toggle  toggle-icon="arrow-forward" pressed="{{autoscroll}}"></icon-toggle>
        </div>

        <div class= "navigation-icons  first-icon">
            <paper-icon-button icon="av:fast-rewind" class="light-blue"  title="Fist image" on-click="first_image"></paper-icon-button>
            <paper-icon-button icon="add-circle" class="light-blue" title="Increase interval" hidden$="[[!autoscroll]]" on-click="increase_interval"  ></paper-icon-button>
            <paper-icon-button icon="remove-circle" class="light-blue" title="Reduce interval" hidden$="[[!autoscroll]]" on-click="decrease_interval"></paper-icon-button>
            <paper-icon-button  icon="av:add-to-queue" class="light-blue" title="Add image to download" hidden$="[[autoscroll]]" on-click="add_to_queue"></paper-icon-button>
            <paper-icon-button icon="av:remove-from-queue" class="light-blue" title="Remove image from download"  hidden$="[[autoscroll]]" on-click="remove_from_queue"></paper-icon-button>
            <paper-icon-button icon="file-download" class="light-blue"  title="Download selected images" hidden$="[[autoscroll]]" on-click="download_images"></paper-icon-button>
            <paper-icon-button icon="av:fast-forward" class="light-blue" title="Last image" on-click="last_image"></paper-icon-button>
        </div>
      </template>
    <dom-if>

</template>
 <script>
     /** Extend Polymer.Element base class
       *  class MyCarousel extends Polymer.Element
     */
    class MyImageCarousel extends MyMixin(Polymer.Element)   {
      static get is() { return 'my-image-carousel' }
      constructor() {
        super();
      }
      /*
      static get properties() {
        return: {
          autoscroll: {
            type: Boolean,
            value: false,
            notify: true,
            reflectToAttribute: true,
            observer: '_autoScroll'
          }

        }
     }
     */
      ready() {
        super.ready();
        console.log("image carousel ready");
        requestAnimationFrame(this._installListeners.bind(this));
      }

      _selectedChanged(selected , oldSelected ) {
          super._selectedChanged(selected, oldSelected);
          if (selected) {
            if (selected !== undefined) {
              var paths =  selected.src.split("/") ;
              this._title = paths[paths.length -1];
            }
            var previous = selected.previousElementSibling;
            var next = selected.nextElementSibling;
            if (this.$.prevBtn !== undefined ) {
              this.$.prevBtn.disabled = !previous ;
              this.$.nextBtn.disabled = !next;
            } else {
              console.log(this.$);
            }

            /* lazy-load images */
            this._loadImage(selected);
            this._loadImage(previous);
            this._loadImage(next);

          } else {
              if (this.$.prevBtn !== undefined ) {
              this.$.prevBtn.disabled = true;
              this.$.nextBtn.disabled = true;
            }
          }
        }

       /**
       *   append the array of images to the parent element
       *   The parent  element (this) is the image-carousel
       */
      appendImage(images) {

        images.forEach( function(image){
          var img  = document.createElement("img");
          img.setAttribute('data-src', this.hosts + image );
          this.appendChild(img);
        },this);

      }
        /**
        * Lazy-load images
        */

      _loadImage(img) {
        /* console.log(img) */
        if (img && !img.src) {
        img.src = img.getAttribute('data-src');
        }
      }

      /* adding transition */
      _translateX(elem, x, transition) {
        if ( elem != undefined ) {
          elem.style.display = 'block';
          elem.style.transition = transition ? 'transform 0.05s' : '';
          /*elem.style.transition = transition ? 'transform' + this.transition+'s' : '';*/
          elem.style.transform = 'translate3d(' + x + 'px, 0, 0)';
        }
      }

      /* set by requestAnimationFrame */
      _installListeners() {
        this.addEventListener('transitionend', this._resetChildrenStyles.bind(this));
      }

      /**
      * The _resetChildrenStyles() method will clear the style attributes that
      * were set by our element. Now we have a carousel that transitions
       between images:
      */
      _resetChildrenStyles() {
        let elem = this.firstElementChild;
        while (elem) {
          elem.style.display = '';
          elem.style.transition = '';
          elem.style.transform = '';
          elem = elem.nextElementSibling;
        }
      }

      _autoScroll() {
        if ( typeof(this.currentInterval)  !=  "undefined ") {
              clearInterval(this.currentInterval)
        }
        console.log("autoscroll",this.int);
        if (this.autoscroll) {
          this.currentInterval = setInterval(_ => this.next_image(), this.int);
          console.log(this.currentInterval);
          }
        }

      /**
      * define two methods, previous() and next(), that will change the selected
      * image. These methods will become part of the element's public API,
      * so they don't start with underscores
      */

      previous_image() {
        const elem = this.selected && this.selected.previousElementSibling;
        if (elem) {
          /* Setup transition start state */
          const oldSelected = this.selected;
          this._translateX(oldSelected, 0);
          this._translateX(elem, -this.offsetWidth);
          /* star the transition */
          this.selected = elem;

          this._translateX(oldSelected, this.offsetWidth, true  );
          this._translateX(elem, 0, true  );

        } else {

          var last  = this.lastElementChild;
          this.selected = last;
          this._translateX(last, 0, true /* transition */);
          this.last_image();
        }

      }

      next_image() {
        const elem = this.selected && this.selected.nextElementSibling;
        if (elem) {
          /**
          * Setup transition start state
          */
          const oldSelected = this.selected;
          this._translateX(oldSelected, 0);
          this._translateX(elem, this.offsetWidth);
          /**
          * star the transition
          */
          this.selected = elem;
          /*
          this._translateX(oldSelected,-this.offsetWidth,this.transition);
          this._translateX(elem, 0, this.transition);
          */
          this._translateX(oldSelected,-this.offsetWidth,false);
          this._translateX(elem, 0, false);


        }  else {

          var first = this.firstElementChild;
          this.selected = first;
          this._translateX(first, 0, true /* transition */);
          this.first_image()
        }

      }



      /**
      * define two more methods, first() and last(), that will jump to the first
      * element or the last element of the caroussel
      */

      first_image() {
        const elem = this.selected ;
        /* this._translateX(elem, 0); */
        this._translateX(elem, this.offsetWidth,true);
        var first = this.firstElementChild;
        this.selected = first;
        this._translateX(first, 0, true /* transition */);
      }

      last_image() {
        const elem = this.selected ;
        /* this._translateX(elem, 0); */
        this._translateX(elem, -this.offsetWidth,true);
        var last = this.lastElementChild;
        this.selected = last;
        this._translateX(last, 0, true /* transition */);
      }

      increase_interval() {
        this.int += this._step;
        if (this.intl > this.max) {
          this.int = this.max;
        }
        console.log(this.interval);
        this._autoScroll();
      }

      decrease_interval() {
        this.int -= this._step;
        if (this.int < this._step) {
          this.int = this._step;
        }
        this._autoScroll();

      }

      set_interval() {
        if (this.int < this._step) {
          this.int = this._step;
        }
        this._autoScroll();
      }

      add_to_queue() {
        var image = this.selected.src;
        var index = this.Images.indexOf(image);
        if (index < 0) {
          this.push("Images", image) ;
        }
      }

      remove_from_queue() {
        var image = this.selected.src;
        var index = this.Images.indexOf(image);
        if ( index >= 0 ) {
          this.splice("Images",index,1) ;
        }
      }

      download_images() {
        var element = this.shadowRoot.querySelector("#download");
        var children = element.children;
        var numChildren = children.length ;

        for ( var i = 0; i < numChildren -1 ; i++ ) {
          simulateClick(children[i]) ;
        }
      }
    }

    function simulateClick(control)  {
      if (document.all) {
       control.click();
       }  else {
         var evObj = document.createEvent('MouseEvents');
         evObj.initMouseEvent('click', true, true, window, 1, 12, 345, 7, 220, false, false, true, false, 0, null );
         control.dispatchEvent(evObj);
       }
     }

    /**
    * Register custom element definition using standard platform API
    */

    customElements.define(MyImageCarousel.is, MyImageCarousel);

 </script>
</dom-module>
